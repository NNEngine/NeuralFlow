<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Flow Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #f8fafc;
            overflow: hidden;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #network-canvas {
            cursor: grab;
        }

        #network-canvas:active {
            cursor: grabbing;
        }

        input[type="range"] {
            accent-color: #38bdf8;
        }

        .btn-primary {
            background: linear-gradient(135deg, #38bdf8 0%, #2563eb 100%);
            transition: all 0.2s ease;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .recording-pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Top Navigation / Controls -->
    <header class="glass-panel px-6 py-4 flex items-center justify-between z-10 border-b">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 btn-primary rounded-lg flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
            </div>
            <h1 class="text-xl font-semibold tracking-tight">Neural<span class="text-sky-400">Flow</span></h1>
        </div>

        <div class="flex items-center gap-6">
            <div class="flex items-center gap-2 text-sm font-medium">
                <button id="playPauseBtn" class="flex items-center gap-2 px-4 py-2 rounded-full glass-panel hover:bg-slate-700 transition-colors">
                    <span id="playIcon">⏸</span> <span id="playText">Pause</span>
                </button>
                <button id="exportBtn" class="flex items-center gap-2 px-4 py-2 rounded-full btn-primary font-semibold text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    Export Video
                </button>
            </div>
        </div>
    </header>

    <main class="flex-1 relative flex overflow-hidden">
        
        <!-- Left Sidebar: Configuration -->
        <aside class="w-80 glass-panel p-6 border-r flex flex-col gap-8 z-10 overflow-y-auto">
            <div>
                <label class="block text-xs font-bold uppercase tracking-widest text-slate-400 mb-4">Architecture</label>
                
                <div class="space-y-6">
                    <div>
                        <div class="flex justify-between mb-2">
                            <span class="text-sm">Layers</span>
                            <span id="layersVal" class="text-sm font-mono text-sky-400">3</span>
                        </div>
                        <input type="range" id="layersInput" min="2" max="6" value="3" class="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div id="neuronsContainer" class="space-y-4">
                        <!-- Dynamic Neuron Sliders -->
                    </div>
                </div>
            </div>

            <div>
                <label class="block text-xs font-bold uppercase tracking-widest text-slate-400 mb-4">Visuals</label>
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <span class="text-sm">Flow Speed</span>
                        <input type="range" id="speedInput" min="1" max="10" value="5" class="w-24 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-sm">Signal Glow</span>
                        <input type="checkbox" id="glowToggle" checked class="w-4 h-4 rounded text-sky-500 focus:ring-sky-500">
                    </div>
                </div>
            </div>

            <div class="mt-auto pt-6 border-t border-slate-700/50">
                <p class="text-xs text-slate-500 leading-relaxed italic">
                    Waves indicate data packets moving between activation functions. Higher layer density increases computation overhead.
                </p>
            </div>
        </aside>

        <!-- Canvas Area -->
        <section id="canvasContainer" class="flex-1 relative bg-[#020617]">
            <canvas id="network-canvas"></canvas>
            
            <!-- Recording Indicator -->
            <div id="recordingIndicator" class="hidden absolute top-4 left-4 flex items-center gap-2 bg-red-500/20 border border-red-500/50 px-3 py-1 rounded-full text-red-400 text-xs font-bold uppercase tracking-tighter">
                <span class="w-2 h-2 bg-red-500 rounded-full recording-pulse"></span>
                Recording...
            </div>
        </section>
    </main>

    <script>
        /**
         * Neural Flow Visualizer Logic
         */
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const layersInput = document.getElementById('layersInput');
        const neuronsContainer = document.getElementById('neuronsContainer');
        const layersValLabel = document.getElementById('layersVal');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const exportBtn = document.getElementById('exportBtn');
        const recordingIndicator = document.getElementById('recordingIndicator');

        let width, height;
        let layers = [];
        let particles = [];
        let isPlaying = true;
        let signalTime = 0;
        let animationFrameId;
        let layerConfig = [4, 6, 2]; // Initial default
        
        // Recording State
        let mediaRecorder;
        let recordedChunks = [];

        class Neuron {
            constructor(x, y, layerIdx, neuronIdx) {
                this.x = x;
                this.y = y;
                this.layerIdx = layerIdx;
                this.neuronIdx = neuronIdx;
                this.radius = 14;
                this.pulse = 0;
            }

            draw() {
                const isActive = (Math.floor(signalTime * 1.5) % layers.length) === this.layerIdx;
                
                // Outer Glow
                if (isActive) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#38bdf8';
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = isActive ? '#38bdf8' : '#1e293b';
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Inner Detail
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = isActive ? '#fff' : '#0f172a';
                ctx.fill();
            }
        }

        class Connection {
            constructor(start, end) {
                this.start = start;
                this.end = end;
            }

            draw() {
                const cp1x = this.start.x + (this.end.x - this.start.x) / 2;
                const cp1y = this.start.y;
                const cp2x = this.start.x + (this.end.x - this.start.x) / 2;
                const cp2y = this.end.y;

                ctx.beginPath();
                ctx.moveTo(this.start.x, this.start.y);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, this.end.x, this.end.y);
                
                const progress = (signalTime * 1.5) % layers.length;
                const isFlowing = progress >= this.start.layerIdx && progress < this.end.layerIdx;

                ctx.strokeStyle = isFlowing ? 'rgba(56, 189, 248, 0.4)' : 'rgba(51, 65, 85, 0.2)';
                ctx.lineWidth = isFlowing ? 2 : 1;
                ctx.stroke();

                // Flowing Particle
                if (isFlowing && isPlaying) {
                    const t = (progress - this.start.layerIdx); // 0 to 1
                    this.drawFlowParticle(t, cp1x, cp1y, cp2x, cp2y);
                }
            }

            drawFlowParticle(t, cp1x, cp1y, cp2x, cp2y) {
                // Cubic Bezier interpolation
                const cx = (1 - t) ** 3 * this.start.x + 3 * (1 - t) ** 2 * t * cp1x + 3 * (1 - t) * t ** 2 * cp2x + t ** 3 * this.end.x;
                const cy = (1 - t) ** 3 * this.start.y + 3 * (1 - t) ** 2 * t * cp1y + 3 * (1 - t) * t ** 2 * cp2y + t ** 3 * this.end.y;

                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#38bdf8';
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function initNetwork() {
            layers = [];
            const layerCount = layerConfig.length;
            const xStep = width / (layerCount + 1);

            for (let i = 0; i < layerCount; i++) {
                const neuronCount = layerConfig[i];
                const layerNeurons = [];
                const yStep = height / (neuronCount + 1);

                for (let j = 0; j < neuronCount; j++) {
                    layerNeurons.push(new Neuron(xStep * (i + 1), yStep * (j + 1), i, j));
                }
                layers.push(layerNeurons);
            }
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            initNetwork();
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            const speed = parseFloat(document.getElementById('speedInput').value) / 100;
            if (isPlaying) signalTime += speed;

            // Draw Connections
            for (let i = 0; i < layers.length - 1; i++) {
                for (let n1 of layers[i]) {
                    for (let n2 of layers[i + 1]) {
                        new Connection(n1, n2).draw();
                    }
                }
            }

            // Draw Neurons
            for (let layer of layers) {
                for (let neuron of layer) {
                    neuron.draw();
                }
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        // UI Building Logic
        function buildNeuronControls() {
            neuronsContainer.innerHTML = '';
            layerConfig.forEach((count, i) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <div class="flex justify-between mb-1">
                        <span class="text-xs text-slate-400">Layer ${i + 1} Neurons</span>
                        <span class="text-xs font-mono">${count}</span>
                    </div>
                    <input type="range" min="1" max="12" value="${count}" 
                        class="w-full h-1 bg-slate-800 rounded-lg appearance-none cursor-pointer layer-neuron-input" 
                        data-index="${i}">
                `;
                neuronsContainer.appendChild(div);
            });

            document.querySelectorAll('.layer-neuron-input').forEach(input => {
                input.oninput = (e) => {
                    const idx = parseInt(e.target.dataset.index);
                    layerConfig[idx] = parseInt(e.target.value);
                    initNetwork();
                    e.target.previousElementSibling.querySelector('span:last-child').textContent = e.target.value;
                };
            });
        }

        layersInput.oninput = (e) => {
            const val = parseInt(e.target.value);
            layersValLabel.textContent = val;
            
            // Adjust config array length
            if (val > layerConfig.length) {
                while (layerConfig.length < val) layerConfig.push(4);
            } else {
                layerConfig = layerConfig.slice(0, val);
            }
            
            buildNeuronControls();
            initNetwork();
        };

        playPauseBtn.onclick = () => {
            isPlaying = !isPlaying;
            document.getElementById('playIcon').textContent = isPlaying ? '⏸' : '▶';
            document.getElementById('playText').textContent = isPlaying ? 'Pause' : 'Play';
        };

        // Video Export Implementation
        exportBtn.onclick = async () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                return;
            }

            recordedChunks = [];
            const stream = canvas.captureStream(60); // 60 FPS
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9'
            });

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `neural-flow-${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
                
                exportBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    Export Video
                `;
                recordingIndicator.classList.add('hidden');
                exportBtn.classList.remove('bg-red-500');
            };

            // Start recording
            mediaRecorder.start();
            recordingIndicator.classList.remove('hidden');
            exportBtn.innerHTML = 'Stop Recording';
            exportBtn.classList.add('bg-red-500');

            // Optional: Auto-stop after 10 seconds to prevent massive files
            setTimeout(() => {
                if (mediaRecorder.state === 'recording') mediaRecorder.stop();
            }, 10000);
        };

        // Window Event Listeners
        window.addEventListener('resize', resize);
        window.onload = () => {
            resize();
            buildNeuronControls();
            animate();
        };

    </script>
</body>
</html>

